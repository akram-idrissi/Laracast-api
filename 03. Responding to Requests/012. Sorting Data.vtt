WEBVTT

00:00:00.000 --> 00:00:10.000
In this episode, we are going to implement the ability to sort our data.

00:00:10.000 --> 00:00:14.160
But before we do that, we need to get our user model and

00:00:14.160 --> 00:00:19.719
our author controller all up to speed as far as our filtering is concerned.

00:00:19.719 --> 00:00:24.760
So let's start with our user model and let's create that scope filter method so

00:00:24.760 --> 00:00:27.600
that we will get the eloquent query builder.

00:00:27.879 --> 00:00:31.280
And then we will get our query filter so

00:00:31.280 --> 00:00:37.400
that we can call the apply method and then pass in the builder there.

00:00:37.400 --> 00:00:41.279
So that's going to kickstart that process so

00:00:41.279 --> 00:00:45.919
that then we just need to create our author filter.

00:00:45.919 --> 00:00:47.360
And let's do this.

00:00:47.360 --> 00:00:53.759
Let's copy our ticket filter and let's rename that to author filter.

00:00:53.759 --> 00:00:57.160
We of course need to change the name of the class.

00:00:57.160 --> 00:01:00.360
But this is going to give us a lot of functionality that we need.

00:01:00.360 --> 00:01:04.919
Like for example, created at and updated at are going to be the same.

00:01:04.919 --> 00:01:06.800
So we don't need to touch those.

00:01:06.800 --> 00:01:08.639
Include is going to be the same.

00:01:08.639 --> 00:01:10.320
Status, however, is not.

00:01:10.320 --> 00:01:12.720
But we can reuse this functionality so

00:01:12.720 --> 00:01:19.400
that if we wanted to filter based upon a set of IDs, then we can do that.

00:01:19.400 --> 00:01:23.279
We have the functionality, we just need to change the name of the method and

00:01:23.279 --> 00:01:26.239
the name of the database column that we query on.

00:01:26.279 --> 00:01:27.639
So we're good there.

00:01:27.639 --> 00:01:31.480
And then the title is the same functionality for the email.

00:01:31.480 --> 00:01:35.680
Because this way we can filter based upon a partial email.

00:01:35.680 --> 00:01:38.440
And we also have a name attribute as well.

00:01:38.440 --> 00:01:40.720
So let's just copy and paste.

00:01:40.720 --> 00:01:45.879
We'll change the name of that method to name and then the column is name.

00:01:45.879 --> 00:01:48.599
So there we go, we have our author filter.

00:01:48.599 --> 00:01:53.360
So now we can go to the author controller and we can change our index method.

00:01:53.400 --> 00:01:57.680
So that instead of including all of that manually,

00:01:57.680 --> 00:02:01.919
we will rely upon our author filter to do that for us.

00:02:01.919 --> 00:02:05.199
So that's here we will call user and then filter.

00:02:05.199 --> 00:02:09.279
We will pass in the filters and then we will paginate the results.

00:02:09.279 --> 00:02:12.399
So let's do a sanity check and make sure that this is going to work.

00:02:12.399 --> 00:02:14.639
So we will have our filter.

00:02:14.639 --> 00:02:16.600
We want to filter on the ID.

00:02:16.600 --> 00:02:23.119
And then let's say that we want the users with an ID of one, six, and

00:02:23.160 --> 00:02:25.880
I forget how many users we have.

00:02:25.880 --> 00:02:27.839
Do we have 15 users?

00:02:27.839 --> 00:02:28.960
We'll try it and see.

00:02:28.960 --> 00:02:33.399
We will have the user with an ID of one, user with an ID of six,

00:02:33.399 --> 00:02:36.960
and no user with an ID of 15.

00:02:36.960 --> 00:02:39.119
So I guess we have just ten users.

00:02:39.119 --> 00:02:40.960
So let's change that.

00:02:40.960 --> 00:02:42.520
So that's one, six, and ten.

00:02:42.520 --> 00:02:44.360
And sure enough, there's the tenth.

00:02:44.360 --> 00:02:47.559
So we're good as far as our user filter is concerned.

00:02:47.559 --> 00:02:49.360
So we can close that out.

00:02:49.360 --> 00:02:51.759
And now let's talk about our sort.

00:02:51.759 --> 00:02:57.119
So our sort, of course, is going to be provided via the query string.

00:02:57.119 --> 00:02:59.119
We could have a sort parameter.

00:02:59.119 --> 00:03:01.679
And in fact, we could do something like we did with the filter.

00:03:01.679 --> 00:03:07.160
So that we could have sort and then we could specify the column as a key,

00:03:07.160 --> 00:03:08.520
like for the title.

00:03:08.520 --> 00:03:13.320
And then we could have the value as being ascending or descending.

00:03:13.320 --> 00:03:14.800
And that would work.

00:03:14.800 --> 00:03:18.759
But, you know, then if we wanted to sort by multiple columns,

00:03:18.759 --> 00:03:22.479
then we would have to have sort and then like status.

00:03:22.479 --> 00:03:26.399
And then it's just, it gets very verbose very quickly.

00:03:26.399 --> 00:03:30.559
And I'm not sure I want to do that for something as simple as sorting.

00:03:30.559 --> 00:03:35.720
Because with sorting, we have two values, ascending, descending, that's it.

00:03:35.720 --> 00:03:37.800
So maybe we should do something like this,

00:03:37.800 --> 00:03:42.360
to where we would have just a single sort query string parameter.

00:03:42.360 --> 00:03:45.160
And then we could have just a comma separated value,

00:03:45.160 --> 00:03:46.839
so that we could have title.

00:03:46.839 --> 00:03:50.800
And if we wanted to also then filter or sort by status,

00:03:50.800 --> 00:03:52.839
I'm used to saying filter.

00:03:52.839 --> 00:03:56.199
If we wanted to sort by title and then status,

00:03:56.199 --> 00:03:58.759
then we can do that just separate them with a comma.

00:03:58.759 --> 00:03:59.600
And then that would work.

00:03:59.600 --> 00:04:02.559
And the default would be ascending sort.

00:04:02.559 --> 00:04:05.479
And then we could specify a descending sort

00:04:05.479 --> 00:04:08.160
by putting a minus sign before the column name.

00:04:08.160 --> 00:04:09.520
And I think that that's fine.

00:04:09.520 --> 00:04:11.679
It's nice, simple, clean.

00:04:11.679 --> 00:04:12.679
Yeah, let's do it.

00:04:12.679 --> 00:04:16.040
So let's do this inside of our query filter.

00:04:16.040 --> 00:04:19.359
Because we have all of the plumbing set up already

00:04:19.359 --> 00:04:21.959
to parse out stuff in the query string.

00:04:21.959 --> 00:04:26.399
So from a functionality standpoint, it just kind of makes sense to do this here.

00:04:26.399 --> 00:04:29.279
I'm going to reorder this so that we are in alphabetical order,

00:04:29.279 --> 00:04:30.679
because I'm that way.

00:04:30.679 --> 00:04:35.279
And then we will essentially do what we did like for the filter.

00:04:35.279 --> 00:04:38.519
So that we will have a protected function,

00:04:38.519 --> 00:04:42.920
we'll call it sort, to where we will get the parameter value.

00:04:42.920 --> 00:04:46.279
And since this can be a comma-separated list of values,

00:04:46.279 --> 00:04:49.839
let's first of all convert that into an array.

00:04:49.839 --> 00:04:53.399
So we'll have a variable called sort attributes

00:04:53.399 --> 00:04:58.760
to where we will explode on a comma for the value.

00:04:58.760 --> 00:05:04.160
And then we could iterate over each one of these attributes.

00:05:04.160 --> 00:05:08.679
And we'll just call that as a sort attribute.

00:05:08.679 --> 00:05:13.440
And here we need to determine the direction of our sort.

00:05:13.440 --> 00:05:18.839
And we'll say that the default is going to be an ascending sort.

00:05:18.839 --> 00:05:22.279
So to check to see if we need a descending sort,

00:05:22.279 --> 00:05:27.239
we can check the first character in the sort attribute.

00:05:27.239 --> 00:05:33.000
And if it is a minus sign, then we know that this is a descending sort.

00:05:33.000 --> 00:05:37.559
So we will need to change the direction to descending.

00:05:37.559 --> 00:05:42.519
But then we can also go ahead and we can normalize our sort attribute here.

00:05:42.519 --> 00:05:45.679
Because this is going to have a minus sign in front of it,

00:05:45.679 --> 00:05:53.079
we can take that out by getting the substring of our sort attribute,

00:05:53.079 --> 00:05:55.440
starting with the position of one.

00:05:55.440 --> 00:05:58.920
So that will give us just the column name that we need there.

00:05:58.920 --> 00:06:02.200
And since we have the direction, all we would need to do

00:06:02.200 --> 00:06:06.559
is use the builder, order by the sort attribute,

00:06:06.559 --> 00:06:08.239
and then the direction.

00:06:08.239 --> 00:06:09.359
And that should work.

00:06:09.359 --> 00:06:13.279
So let's go back to Postman and let's sort by title.

00:06:13.279 --> 00:06:16.279
And we should start with the As we do.

00:06:16.279 --> 00:06:18.559
So it looks like that that's going to work fine.

00:06:18.559 --> 00:06:22.799
If we say to sort in descending order for our title,

00:06:22.799 --> 00:06:25.559
yes, that works just fine as well.

00:06:25.559 --> 00:06:29.359
Let's change that so that we now sort by the status.

00:06:29.359 --> 00:06:33.040
We should start with the status of A for the active statuses.

00:06:33.079 --> 00:06:38.320
But then let's say that, okay, we want to then sort by title descending.

00:06:38.320 --> 00:06:41.799
In which case, yep, so we are sorting by the status

00:06:41.799 --> 00:06:44.399
and then title in descending order.

00:06:44.399 --> 00:06:47.799
So yeah, that's looking great.

00:06:47.799 --> 00:06:48.920
Except for this.

00:06:48.920 --> 00:06:53.679
What if someone says, okay, I want to sort by whatever?

00:06:53.679 --> 00:06:57.799
Well, we're going to get an error because there is no whatever column

00:06:57.799 --> 00:06:59.839
inside of our tickets table.

00:06:59.839 --> 00:07:05.959
So we kind of need to filter out anything that we don't want to sort by

00:07:05.959 --> 00:07:11.480
so that we could have kind of a privileged list of what is sortable.

00:07:11.480 --> 00:07:16.200
So inside of our query filter, we could create a sortable.

00:07:16.200 --> 00:07:19.320
And we could initialize that as an empty array.

00:07:19.320 --> 00:07:24.079
And then inside of our ticket filter, we could then override that

00:07:24.079 --> 00:07:28.959
to specify the columns that we want to allow to be sortable.

00:07:28.959 --> 00:07:33.920
So this could be title, and then we could say status as well.

00:07:33.920 --> 00:07:38.239
And then inside of our query filter, we will need to check to see

00:07:38.239 --> 00:07:43.799
if our sort attribute is inside of the sortable array.

00:07:43.799 --> 00:07:45.119
So we'll do it like this.

00:07:45.119 --> 00:07:50.399
If not in array, then we are just going to continue

00:07:50.399 --> 00:07:54.760
because it's not an attribute that we want to sort by.

00:07:54.760 --> 00:07:56.720
So we'll just ignore it.

00:07:56.720 --> 00:08:01.679
But if it is in the array, then of course it is added to the query builder.

00:08:01.679 --> 00:08:03.440
So we can test this out now.

00:08:03.440 --> 00:08:07.239
If we submit the same request, this error should go away

00:08:07.239 --> 00:08:08.920
and we should get our results.

00:08:08.920 --> 00:08:10.119
That's perfect.

00:08:10.119 --> 00:08:12.000
That's exactly what we want.

00:08:12.000 --> 00:08:18.519
And we can sort by whatever, and then status, and then a descending title.

00:08:18.519 --> 00:08:21.519
And we would get kind of the same results as we got before

00:08:21.519 --> 00:08:23.839
because whatever is being ignored.

00:08:23.839 --> 00:08:24.720
And that's great.

00:08:24.720 --> 00:08:27.320
Except what about createdAt?

00:08:27.320 --> 00:08:33.280
Because createdAt is a valid attribute, but it is in camel case.

00:08:33.280 --> 00:08:39.320
And the database is going to expect it to be in the format that it is in the table,

00:08:39.320 --> 00:08:41.280
created underscore at.

00:08:41.280 --> 00:08:42.960
So let's look at this.

00:08:42.960 --> 00:08:47.400
If we add createdAt here to our sortable array,

00:08:47.400 --> 00:08:50.880
and then we submit the request, we get that error again.

00:08:50.880 --> 00:08:55.039
So what if we do something like this to where our sortable array,

00:08:55.039 --> 00:08:59.640
we can have just the straight normal column names or the attributes,

00:08:59.640 --> 00:09:05.159
but then if we needed to translate an attribute into an actual database column,

00:09:05.159 --> 00:09:06.520
we could do something like that.

00:09:06.520 --> 00:09:09.400
Which means that inside of our query filter,

00:09:09.400 --> 00:09:11.960
we're going to need a little bit more here.

00:09:11.960 --> 00:09:16.119
So that if it is not inside of the sortable array,

00:09:16.119 --> 00:09:23.159
and it does not exist as a key inside of the sortable array,

00:09:23.159 --> 00:09:25.400
then we will ignore it.

00:09:25.400 --> 00:09:26.919
So just like before.

00:09:26.919 --> 00:09:32.080
So if the provided sort attribute is not in the array,

00:09:32.080 --> 00:09:35.000
or if it's not a key in the array,

00:09:35.000 --> 00:09:37.159
then we continue on, we ignore it.

00:09:37.159 --> 00:09:41.280
Otherwise, we have a valid attribute that we want to use,

00:09:41.280 --> 00:09:43.320
but we need to do something like this.

00:09:43.359 --> 00:09:47.159
Let's get column name so that we will use our sortable

00:09:47.159 --> 00:09:51.919
and try to get the value for the sort attribute key.

00:09:51.919 --> 00:09:54.440
So in the case of our createdAt,

00:09:54.440 --> 00:09:57.960
that means that we would be providing the createdAt key

00:09:57.960 --> 00:10:00.400
to get to the createdAt value.

00:10:00.400 --> 00:10:01.799
And if you're not looking at the screen,

00:10:01.799 --> 00:10:05.919
that makes completely and totally nonsense.

00:10:05.919 --> 00:10:08.520
But that's exactly what it is.

00:10:08.520 --> 00:10:12.479
However, in the case of something like title or status,

00:10:12.520 --> 00:10:16.479
the value is not going to be there because that's not a key.

00:10:16.479 --> 00:10:18.159
So we could do something like this.

00:10:18.159 --> 00:10:22.239
So that if this is a key in the sortable array,

00:10:22.239 --> 00:10:25.119
we will get the value, otherwise it's going to be null.

00:10:25.119 --> 00:10:29.000
But then we can check if the column name is null,

00:10:29.000 --> 00:10:34.479
then we are going to set the column name equal to the sort attribute.

00:10:34.479 --> 00:10:37.719
So that in the case of status and title,

00:10:37.719 --> 00:10:41.640
this is going to set our column name back to those values.

00:10:41.640 --> 00:10:46.239
Otherwise, it's going to be the value of created underscore at.

00:10:46.239 --> 00:10:49.719
And we can go ahead and we could do the updatedAt as well,

00:10:49.719 --> 00:10:51.880
so that that will be in place.

00:10:51.880 --> 00:10:55.239
So that then inside of our query filter,

00:10:55.239 --> 00:10:57.280
instead of using our sort attribute,

00:10:57.280 --> 00:10:58.840
we will use the column name.

00:10:58.840 --> 00:11:03.200
We already know the direction and that should work.

00:11:03.200 --> 00:11:07.159
So now we should sort on the createdAt attribute,

00:11:07.159 --> 00:11:09.479
but this is going to be in descending order.

00:11:10.400 --> 00:11:13.200
Okay, I mistyped the field.

00:11:13.200 --> 00:11:16.440
So that is createdAt, not createAt.

00:11:16.440 --> 00:11:17.479
So let's go back.

00:11:17.479 --> 00:11:19.599
Sure enough, we now get our data.

00:11:19.599 --> 00:11:24.159
If we look at the createdAt, we can see that that was February 4th.

00:11:24.159 --> 00:11:26.640
That is the latest one.

00:11:26.640 --> 00:11:30.280
And if we scroll on down, we see February 3rd.

00:11:30.280 --> 00:11:33.440
Then we are going to see a ton of February 2nd.

00:11:33.440 --> 00:11:36.919
But if we switch this to be in ascending order,

00:11:36.919 --> 00:11:39.880
we will start at February 1st.

00:11:39.880 --> 00:11:42.400
Then if we want to sort by the title,

00:11:42.400 --> 00:11:47.520
we will see that our first ticket is still from February 1st.

00:11:47.520 --> 00:11:51.640
But then we have February 2nd, the title starts with A,

00:11:51.640 --> 00:11:55.400
and everything is sorting exactly as it should.

00:11:55.400 --> 00:12:00.159
So we are good to go as far as our sort capability is concerned.

00:12:00.159 --> 00:12:02.760
Let's go ahead and go to the author filter.

00:12:02.760 --> 00:12:05.799
And let's copy what we have from the ticket filter

00:12:05.799 --> 00:12:07.799
as far as our sortable array.

00:12:07.799 --> 00:12:09.919
And then we will just set this up

00:12:09.919 --> 00:12:14.159
so that we can sort based upon the name, the email.

00:12:14.159 --> 00:12:16.960
I guess we would want to sort by the ID.

00:12:16.960 --> 00:12:19.320
I guess that's something that we would want to do.

00:12:19.320 --> 00:12:22.679
Or maybe not, who cares if we don't sort by ID.

00:12:22.679 --> 00:12:24.760
Definitely name, definitely email,

00:12:24.760 --> 00:12:27.880
createdAt, updatedAt, everything else is fine.

00:12:27.880 --> 00:12:29.159
And we know that it's going to work

00:12:29.159 --> 00:12:32.159
because, well, we've tested it on our tickets.

00:12:32.159 --> 00:12:34.359
And the really awesome thing about this

00:12:34.359 --> 00:12:38.080
is if we go back to our nested controller

00:12:38.080 --> 00:12:40.400
for the author tickets,

00:12:40.400 --> 00:12:42.840
not only can we include the filter,

00:12:42.840 --> 00:12:45.640
but we can also include the sort.

00:12:45.640 --> 00:12:49.640
I don't remember how many active tickets we have.

00:12:49.640 --> 00:12:51.039
Looks like we have several.

00:12:51.039 --> 00:12:55.239
So let's sort by the title descending.

00:12:55.239 --> 00:12:58.080
And we will see that starts with an L,

00:12:58.080 --> 00:13:00.799
that starts with a D, that works just fine

00:13:00.799 --> 00:13:03.840
because it's all built into our query filter.

